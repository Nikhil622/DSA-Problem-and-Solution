class Solution{
	public:
	int isPossiblePalindrome(string s, int k)
	{   int n=s.size();
	    string p=s;
	    reverse(p.begin(),p.end());
	    int t[n+1][n+1];
	   for(int i=0;i<=n;++i)
	     t[i][0]=0;
	   for(int j=0;j<=n;++j)
	     t[0][j]=0;
	   for(int i=1;i<=n;++i)
	   {
	       for(int j=1;j<=n;++j)
	       {
	           if(s[i-1]==p[j-1])
	             t[i][j]=1+t[i-1][j-1];
	           else
	             t[i][j]=max(t[i][j-1],t[i-1][j]);
	       }
	   }
	   return (n-t[n][n])<=k;  // t[n][n] is longest pallindromic subsequence // So remaining characters which are not part of it (n-t[n][n]) should be smaller than k
	}
	  
};
