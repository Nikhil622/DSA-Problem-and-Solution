class Solution 
{
    public:
    //Function to find minimum time required to rot all oranges. 
    int orangesRotting(vector<vector<int>>& grid) {
        int m=grid.size(),n=grid[0].size();
        queue<pair<int,int>>q;
        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));
        for(int i=0;i<m;++i)
        {
            for(int j=0;j<n;++j)
             {  if(grid[i][j]==2)
                 { q.push({i,j});
                   dist[i][j]=0;  
                 }
                class Solution 
{
    public:
    //Function to find minimum time required to rot all oranges. 
    int orangesRotting(vector<vector<int>>& grid) {
        int m=grid.size(),n=grid[0].size();
        queue<pair<int,int>>q;
        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));
        for(int i=0;i<m;++i)
        {
            for(int j=0;j<n;++j)
             {  if(grid[i][j]==2)
                 { q.push({i,j});
                   dist[i][j]=0;  
                 }
                else if(grid[i][j]==0) // These cell cannot be reached
                  dist[i][j]=-1;
             }
        }
        static int a[]={0,0,-1,1};
        static int b[]={-1,1,0,0};
        while(q.empty()==false)
        {  auto p=q.front();
           q.pop();
           for(int k=0;k<4;++k)
           {  int i=p.first+a[k],j=p.second+b[k];
             if(i>=0 && i<m && j>=0 && j<n && dist[i][j]>dist[p.first][p.second]+1)
               {  dist[i][j]=dist[p.first][p.second]+1;
                  q.push({i,j}); 
               }
           }
        }
        int res=INT_MIN;
        for(int i=0;i<m;++i)
        {
            for(int j=0;j<n;++j)
             {  if(grid[i][j]==1)
                  res=max(res,dist[i][j]);
             }
        }
        if(res==INT_MAX)
          return -1;
        return res;
    }
};
             }
        }
        static int a[]={0,0,-1,1};
        static int b[]={-1,1,0,0};
        while(q.empty()==false)
        {  auto p=q.front();
           q.pop();
           for(int k=0;k<4;++k)
           {  int i=p.first+a[k],j=p.second+b[k];
             if(i>=0 && i<m && j>=0 && j<n && dist[i][j]>dist[p.first][p.second]+1)
               {  dist[i][j]=dist[p.first][p.second]+1;
                  q.push({i,j}); 
               }
           }
        }
        int res=INT_MIN;
        for(int i=0;i<m;++i)
        {
            for(int j=0;j<n;++j)
             {  if(grid[i][j]==1)
                  res=max(res,dist[i][j]);
             }
        }
        if(res==INT_MAX)
          return -1;
        return res;
    }
};
